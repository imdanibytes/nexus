// This file is auto-generated by @hey-api/openapi-ts

import type { Client, Options as Options2, TDataShape } from './client';
import { client } from './client.gen';
import type { CallExtensionData, CallExtensionErrors, CallExtensionResponses, ContainerStatsData, ContainerStatsErrors, ContainerStatsResponses, EditFileData, EditFileErrors, EditFileResponses, ExecCommandData, ExecCommandErrors, ExecCommandResponses, GetSettingsData, GetSettingsErrors, GetSettingsResponses, GlobFilesData, GlobFilesErrors, GlobFilesResponses, GrepFilesData, GrepFilesErrors, GrepFilesResponses, ListContainersData, ListContainersErrors, ListContainersResponses, ListDirData, ListDirErrors, ListDirResponses, ListExtensionsData, ListExtensionsErrors, ListExtensionsResponses, ListProcessesData, ListProcessesErrors, ListProcessesResponses, ProxyRequestData, ProxyRequestErrors, ProxyRequestResponses, PutSettingsData, PutSettingsErrors, PutSettingsResponses, ReadFileData, ReadFileErrors, ReadFileResponses, SystemInfoData, SystemInfoErrors, SystemInfoResponses, WriteFileData, WriteFileErrors, WriteFileResponses } from './types.gen';

export type Options<TData extends TDataShape = TDataShape, ThrowOnError extends boolean = boolean> = Options2<TData, ThrowOnError> & {
    /**
     * You can provide a client instance returned by `createClient()` instead of
     * individual options. This might be also useful if you want to implement a
     * custom client.
     */
    client?: Client;
    /**
     * You can pass arbitrary values through the `meta` object. This can be
     * used to access values that aren't defined as part of the SDK function.
     */
    meta?: Record<string, unknown>;
};

export const listContainers = <ThrowOnError extends boolean = false>(options?: Options<ListContainersData, ThrowOnError>) => (options?.client ?? client).get<ListContainersResponses, ListContainersErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/docker/containers',
    ...options
});

export const containerStats = <ThrowOnError extends boolean = false>(options: Options<ContainerStatsData, ThrowOnError>) => (options.client ?? client).get<ContainerStatsResponses, ContainerStatsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/docker/stats/{id}',
    ...options
});

/**
 * List extensions declared by the calling plugin.
 *
 * Only returns extensions the plugin declared in its manifest `"extensions"` field.
 * Includes availability status (is it installed and running?) and per-operation
 * permission status. Plugins cannot see extensions they didn't declare.
 */
export const listExtensions = <ThrowOnError extends boolean = false>(options?: Options<ListExtensionsData, ThrowOnError>) => (options?.client ?? client).get<ListExtensionsResponses, ListExtensionsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/extensions',
    ...options
});

/**
 * Execute an extension operation.
 *
 * Three-layer security model:
 * 1. PERMISSION: Does this plugin have `ext:{ext_id}:{operation}`?
 * 2. SCOPE: If the operation declares `scope_key`, is the scope value approved?
 * 3. RISK: If risk_level is high, per-invocation runtime approval.
 */
export const callExtension = <ThrowOnError extends boolean = false>(options: Options<CallExtensionData, ThrowOnError>) => (options.client ?? client).post<CallExtensionResponses, CallExtensionErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/extensions/{ext_id}/{operation}',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

export const editFile = <ThrowOnError extends boolean = false>(options: Options<EditFileData, ThrowOnError>) => (options.client ?? client).post<EditFileResponses, EditFileErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/fs/edit',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

export const globFiles = <ThrowOnError extends boolean = false>(options: Options<GlobFilesData, ThrowOnError>) => (options.client ?? client).get<GlobFilesResponses, GlobFilesErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/fs/glob',
    ...options
});

export const grepFiles = <ThrowOnError extends boolean = false>(options: Options<GrepFilesData, ThrowOnError>) => (options.client ?? client).get<GrepFilesResponses, GrepFilesErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/fs/grep',
    ...options
});

export const listDir = <ThrowOnError extends boolean = false>(options: Options<ListDirData, ThrowOnError>) => (options.client ?? client).get<ListDirResponses, ListDirErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/fs/list',
    ...options
});

export const readFile = <ThrowOnError extends boolean = false>(options: Options<ReadFileData, ThrowOnError>) => (options.client ?? client).get<ReadFileResponses, ReadFileErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/fs/read',
    ...options
});

export const writeFile = <ThrowOnError extends boolean = false>(options: Options<WriteFileData, ThrowOnError>) => (options.client ?? client).post<WriteFileResponses, WriteFileErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/fs/write',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

export const proxyRequest = <ThrowOnError extends boolean = false>(options: Options<ProxyRequestData, ThrowOnError>) => (options.client ?? client).post<ProxyRequestResponses, ProxyRequestErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/network/proxy',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

export const execCommand = <ThrowOnError extends boolean = false>(options: Options<ExecCommandData, ThrowOnError>) => (options.client ?? client).post<ExecCommandResponses, ExecCommandErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/process/exec',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

export const listProcesses = <ThrowOnError extends boolean = false>(options?: Options<ListProcessesData, ThrowOnError>) => (options?.client ?? client).get<ListProcessesResponses, ListProcessesErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/process/list',
    ...options
});

/**
 * Get settings for the authenticated plugin.
 *
 * Returns a flat key-value map. Defaults from the manifest are
 * applied first, then any explicitly saved overrides.
 */
export const getSettings = <ThrowOnError extends boolean = false>(options?: Options<GetSettingsData, ThrowOnError>) => (options?.client ?? client).get<GetSettingsResponses, GetSettingsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/settings',
    ...options
});

/**
 * Update settings for the authenticated plugin.
 *
 * Accepts a flat key-value map. Values are validated against the manifest's
 * settings schema: unknown keys are rejected, value types must match.
 */
export const putSettings = <ThrowOnError extends boolean = false>(options: Options<PutSettingsData, ThrowOnError>) => (options.client ?? client).put<PutSettingsResponses, PutSettingsErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/settings',
    ...options,
    headers: {
        'Content-Type': 'application/json',
        ...options.headers
    }
});

export const systemInfo = <ThrowOnError extends boolean = false>(options?: Options<SystemInfoData, ThrowOnError>) => (options?.client ?? client).get<SystemInfoResponses, SystemInfoErrors, ThrowOnError>({
    security: [{ scheme: 'bearer', type: 'http' }],
    url: '/api/v1/system/info',
    ...options
});
